use anyhow::Result;
use dotenv::dotenv;
use finfo::query::InfluxFlightClient;

/// InfluxDB Flight æŸ¥è¯¢ç¤ºä¾‹
///
/// è¿™ä¸ªç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ InfluxFlightClient è¿žæŽ¥åˆ° InfluxDB å¹¶æ‰§è¡ŒæŸ¥è¯¢ã€‚
/// åŸºäºŽ Go å®˜æ–¹ç¤ºä¾‹ï¼šhttps://docs.influxdata.com/influxdb3/core/reference/client-libraries/flight/go-flight/
///
/// ä½¿ç”¨æ–¹æ³•ï¼š
/// ```bash
/// cargo run --example influx_flight_query
/// ```
///
/// çŽ¯å¢ƒå˜é‡é…ç½®ï¼š
/// - INFLUX_ENDPOINT: InfluxDB Flight ç«¯ç‚¹ (é»˜è®¤: https://localhost:8181)
/// - INFLUX_TOKEN: InfluxDB API ä»¤ç‰Œ
/// - INFLUX_DATABASE: æ•°æ®åº“åç§° (é»˜è®¤: mydb)

#[tokio::main]
async fn main() -> Result<()> {
    dotenv().ok();
    println!("ðŸš€ InfluxDB Flight æŸ¥è¯¢ç¤ºä¾‹");
    println!("åŸºäºŽ Go å®˜æ–¹ç¤ºä¾‹å®žçŽ°çš„ Rust ç‰ˆæœ¬");
    println!();

    // ä»ŽçŽ¯å¢ƒå˜é‡èŽ·å–é…ç½®ï¼Œæˆ–ä½¿ç”¨é»˜è®¤å€¼
    let endpoint =
        std::env::var("INFLUX_ENDPOINT").unwrap_or_else(|_| "https://localhost:8181".to_string());

    let token = std::env::var("INFLUXDB_AUTH_TOKEN").unwrap();

    let database = std::env::var("INFLUX_DATABASE").unwrap_or_else(|_| "test".to_string());

    println!("ðŸ“¡ è¿žæŽ¥é…ç½®:");
    println!("  ç«¯ç‚¹: {}", endpoint);
    println!("  æ•°æ®åº“: {}", database);
    println!("  ä»¤ç‰Œ: {}***", &token[..std::cmp::min(8, token.len())]);
    println!();

    // åˆ›å»ºå®¢æˆ·ç«¯
    println!("ðŸ”— åˆ›å»º Flight å®¢æˆ·ç«¯...");
    let mut client = match InfluxFlightClient::new(&endpoint, &token, &database).await {
        Ok(client) => {
            println!("âœ… å®¢æˆ·ç«¯åˆ›å»ºæˆåŠŸ");
            client
        }
        Err(e) => {
            println!("âŒ å®¢æˆ·ç«¯åˆ›å»ºå¤±è´¥: {}", e);
            return Err(e.into());
        }
    };

    // æµ‹è¯•è¿žæŽ¥
    println!();
    println!("ðŸ” æµ‹è¯•è¿žæŽ¥...");
    let connected = client.test_connection().await;
    if connected {
        println!("âœ… è¿žæŽ¥æµ‹è¯•æˆåŠŸ");
    } else {
        println!("âš ï¸  è¿žæŽ¥æµ‹è¯•å¤±è´¥ï¼ˆè¿™åœ¨æ¼”ç¤ºçŽ¯å¢ƒä¸­æ˜¯æ­£å¸¸çš„ï¼‰");
    }

    // æ‰§è¡Œç¤ºä¾‹æŸ¥è¯¢
    println!();
    println!("ðŸ“Š æ‰§è¡Œç¤ºä¾‹æŸ¥è¯¢...");

    let queries = vec![
        "SELECT 1 as test_column",
        "SELECT * FROM your_table LIMIT 10",
        "SELECT time, value FROM measurements WHERE time > now() - 1h",
    ];

    for (i, query) in queries.iter().enumerate() {
        println!();
        println!("æŸ¥è¯¢ {}: {}", i + 1, query);

        match client.execute_query(query).await {
            Ok(results) => {
                println!("âœ… æŸ¥è¯¢æˆåŠŸï¼Œè¿”å›ž {} ä¸ª RecordBatch", results.len());

                // åœ¨å®žé™…å®žçŽ°ä¸­ï¼Œè¿™é‡Œä¼šæ˜¾ç¤ºæŸ¥è¯¢ç»“æžœ
                if results.is_empty() {
                    println!("   ðŸ“ æ³¨æ„ï¼šå½“å‰æ˜¯ç®€åŒ–å®žçŽ°ï¼Œè¿”å›žç©ºç»“æžœ");
                } else {
                    for (batch_idx, batch) in results.iter().enumerate() {
                        println!(
                            "   æ‰¹æ¬¡ {}: {} è¡Œ Ã— {} åˆ—",
                            batch_idx + 1,
                            batch.num_rows(),
                            batch.num_columns()
                        );
                    }
                }
            }
            Err(e) => {
                println!("âŒ æŸ¥è¯¢å¤±è´¥: {}", e);
                println!("   ðŸ’¡ è¿™åœ¨æ¼”ç¤ºçŽ¯å¢ƒä¸­æ˜¯æ­£å¸¸çš„ï¼ˆæ²¡æœ‰çœŸå®žçš„ InfluxDB æœåŠ¡å™¨ï¼‰");
            }
        }
    }

    println!();
    println!("ðŸŽ¯ ç¤ºä¾‹å®Œæˆï¼");
    println!();
    println!("ðŸ“š ä¸‹ä¸€æ­¥:");
    println!("1. é…ç½®çœŸå®žçš„ InfluxDB 3.0 æœåŠ¡å™¨");
    println!("2. è®¾ç½®æ­£ç¡®çš„çŽ¯å¢ƒå˜é‡ (INFLUX_ENDPOINT, INFLUX_TOKEN, INFLUX_DATABASE)");
    println!("3. å®žçŽ°å®Œæ•´çš„ FlightData è§£æžé€»è¾‘");
    println!("4. æ·»åŠ é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶");

    Ok(())
}

/// æ˜¾ç¤ºå¦‚ä½•åœ¨ä»£ç ä¸­ç›´æŽ¥ä½¿ç”¨å®¢æˆ·ç«¯
#[allow(dead_code)]
async fn example_usage() -> Result<()> {
    // åˆ›å»ºå®¢æˆ·ç«¯
    let mut client = InfluxFlightClient::new(
        "https://localhost:8181",
        "your-influxdb-token",
        "your-database",
    )
    .await?;

    // æ‰§è¡ŒæŸ¥è¯¢
    let results = client
        .execute_query("SELECT time, temperature, humidity FROM sensors WHERE time > now() - 1h")
        .await?;

    // å¤„ç†ç»“æžœ
    for (i, batch) in results.iter().enumerate() {
        println!("æ‰¹æ¬¡ {}: {} è¡Œæ•°æ®", i + 1, batch.num_rows());

        // åœ¨å®žé™…åº”ç”¨ä¸­ï¼Œä½ å¯ä»¥ï¼š
        // 1. è½¬æ¢ä¸º DataFrame (ä½¿ç”¨ polars æˆ– arrow)
        // 2. åºåˆ—åŒ–ä¸º JSON
        // 3. å†™å…¥æ–‡ä»¶
        // 4. è¿›è¡Œè¿›ä¸€æ­¥çš„æ•°æ®å¤„ç†
    }

    Ok(())
}

/// å±•ç¤ºæ‰¹é‡æŸ¥è¯¢çš„ç”¨æ³•
#[allow(dead_code)]
async fn batch_query_example() -> Result<()> {
    let mut client =
        InfluxFlightClient::new("https://localhost:8181", "your-token", "your-database").await?;

    let queries = vec![
        "SELECT COUNT(*) FROM table1",
        "SELECT AVG(value) FROM table2 WHERE time > now() - 1d",
        "SELECT * FROM table3 ORDER BY time DESC LIMIT 100",
    ];

    for query in queries {
        match client.execute_query(query).await {
            Ok(results) => println!("æŸ¥è¯¢æˆåŠŸ: {} ä¸ªç»“æžœ", results.len()),
            Err(e) => println!("æŸ¥è¯¢å¤±è´¥: {}", e),
        }
    }

    Ok(())
}