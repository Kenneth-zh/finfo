use anyhow::Result;
use dotenv::dotenv;
use finfo::query::InfluxFlightClient;

/// InfluxDB Flight 查询示例
///
/// 这个示例展示了如何使用 InfluxFlightClient 连接到 InfluxDB 并执行查询。
/// 基于 Go 官方示例：https://docs.influxdata.com/influxdb3/core/reference/client-libraries/flight/go-flight/
///
/// 使用方法：
/// ```bash
/// cargo run --example influx_flight_query
/// ```
///
/// 环境变量配置：
/// - INFLUX_ENDPOINT: InfluxDB Flight 端点 (默认: https://localhost:8181)
/// - INFLUX_TOKEN: InfluxDB API 令牌
/// - INFLUX_DATABASE: 数据库名称 (默认: mydb)

#[tokio::main]
async fn main() -> Result<()> {
    dotenv().ok();
    println!("🚀 InfluxDB Flight 查询示例");
    println!("基于 Go 官方示例实现的 Rust 版本");
    println!();

    // 从环境变量获取配置，或使用默认值
    let endpoint =
        std::env::var("INFLUX_ENDPOINT").unwrap_or_else(|_| "https://localhost:8181".to_string());

    let token = std::env::var("INFLUXDB_AUTH_TOKEN").unwrap();

    let database = std::env::var("INFLUX_DATABASE").unwrap_or_else(|_| "test".to_string());

    println!("📡 连接配置:");
    println!("  端点: {}", endpoint);
    println!("  数据库: {}", database);
    println!("  令牌: {}***", &token[..std::cmp::min(8, token.len())]);
    println!();

    // 创建客户端
    println!("🔗 创建 Flight 客户端...");
    let mut client = match InfluxFlightClient::new(&endpoint, &token, &database).await {
        Ok(client) => {
            println!("✅ 客户端创建成功");
            client
        }
        Err(e) => {
            println!("❌ 客户端创建失败: {}", e);
            return Err(e.into());
        }
    };

    // 测试连接
    println!();
    println!("🔍 测试连接...");
    let connected = client.test_connection().await;
    if connected {
        println!("✅ 连接测试成功");
    } else {
        println!("⚠️  连接测试失败（这在演示环境中是正常的）");
    }

    // 执行示例查询
    println!();
    println!("📊 执行示例查询...");

    let queries = vec![
        "SELECT 1 as test_column",
        "SELECT * FROM your_table LIMIT 10",
        "SELECT time, value FROM measurements WHERE time > now() - 1h",
    ];

    for (i, query) in queries.iter().enumerate() {
        println!();
        println!("查询 {}: {}", i + 1, query);

        match client.execute_query(query).await {
            Ok(results) => {
                println!("✅ 查询成功，返回 {} 个 RecordBatch", results.len());

                // 在实际实现中，这里会显示查询结果
                if results.is_empty() {
                    println!("   📝 注意：当前是简化实现，返回空结果");
                } else {
                    for (batch_idx, batch) in results.iter().enumerate() {
                        println!(
                            "   批次 {}: {} 行 × {} 列",
                            batch_idx + 1,
                            batch.num_rows(),
                            batch.num_columns()
                        );
                    }
                }
            }
            Err(e) => {
                println!("❌ 查询失败: {}", e);
                println!("   💡 这在演示环境中是正常的（没有真实的 InfluxDB 服务器）");
            }
        }
    }

    println!();
    println!("🎯 示例完成！");
    println!();
    println!("📚 下一步:");
    println!("1. 配置真实的 InfluxDB 3.0 服务器");
    println!("2. 设置正确的环境变量 (INFLUX_ENDPOINT, INFLUX_TOKEN, INFLUX_DATABASE)");
    println!("3. 实现完整的 FlightData 解析逻辑");
    println!("4. 添加错误处理和重试机制");

    Ok(())
}

/// 显示如何在代码中直接使用客户端
#[allow(dead_code)]
async fn example_usage() -> Result<()> {
    // 创建客户端
    let mut client = InfluxFlightClient::new(
        "https://localhost:8181",
        "your-influxdb-token",
        "your-database",
    )
    .await?;

    // 执行查询
    let results = client
        .execute_query("SELECT time, temperature, humidity FROM sensors WHERE time > now() - 1h")
        .await?;

    // 处理结果
    for (i, batch) in results.iter().enumerate() {
        println!("批次 {}: {} 行数据", i + 1, batch.num_rows());

        // 在实际应用中，你可以：
        // 1. 转换为 DataFrame (使用 polars 或 arrow)
        // 2. 序列化为 JSON
        // 3. 写入文件
        // 4. 进行进一步的数据处理
    }

    Ok(())
}

/// 展示批量查询的用法
#[allow(dead_code)]
async fn batch_query_example() -> Result<()> {
    let mut client =
        InfluxFlightClient::new("https://localhost:8181", "your-token", "your-database").await?;

    let queries = vec![
        "SELECT COUNT(*) FROM table1",
        "SELECT AVG(value) FROM table2 WHERE time > now() - 1d",
        "SELECT * FROM table3 ORDER BY time DESC LIMIT 100",
    ];

    for query in queries {
        match client.execute_query(query).await {
            Ok(results) => println!("查询成功: {} 个结果", results.len()),
            Err(e) => println!("查询失败: {}", e),
        }
    }

    Ok(())
}